---
import { idToFullPath } from "./KnownClasses.js";

interface Props {
    version: string;
    path?: string;
    method?: string;
    params?: string;
    name?: string;
    id?: string;
}

enum Project {
    UNKNOWN,
    PAPER,
    ADVENTURE_SLF4J,
    ADVENTURE_MM,
    ADVENTURE_API,
    JSPECIFY,
    SLF4J,
}

const projects: Map<string, Project> = new Map(
    Object.entries({
        "net.kyori.adventure.text.logger": Project.ADVENTURE_SLF4J,
        "net.kyori.adventure.text.minimessage": Project.ADVENTURE_MM,
        "net.kyori.adventure": Project.ADVENTURE_API,
        "org.jspecify": Project.JSPECIFY,
        "org.slf4j": Project.SLF4J,
    }),
);

let { version = "1.21.4", path, method, params, name, id }: Props = Astro.props;
let prop: Props = { version, path, method, params, name, id };

preprocessProps(prop);
if (prop.path == undefined) {
    throw "No valid path defined!";
}

let fullPath = buildFilePath(prop, getProjectByPath(prop.path));

let finalName = name;
if (name == null && path != null) {
    let splitPath = path.split(".");
    const className = splitPath[splitPath.length - 1];

    if (method == null) {
        finalName = className;
    } else {
        finalName = className + "#" + method;
    }
}

function buildFilePath(props: Props, project: Project): string {
    if (props.path == null) {
        return "about:blank";
    }

    let methodPath = props.method == null ? "" : "#" + props.method;
    if (props.params != null) {
        methodPath +=
            "(" +
            props.params
                .split(",") // TODO: New param format: "Type name, OtherType otherName"
                .map((param) => idToFullPath(param))
                .join(",") +
            ")";
    }

    let modifiedPath = props.path.replaceAll(".", "/").replaceAll("\\/", ".");
    if (project == Project.PAPER) {
        return constructUrl(
            "https://jd.papermc.io/paper/1.21.4/",
            modifiedPath,
            methodPath,
        );
    }

    if (project == Project.ADVENTURE_SLF4J) {
        return constructUrl(
            "https://jd.advntr.dev/text-logger-slf4j/latest/",
            modifiedPath,
            methodPath,
        );
    }

    if (project == Project.ADVENTURE_API) {
        return constructUrl(
            "https://jd.advntr.dev/api/latest/",
            modifiedPath,
            methodPath,
        );
    }

    if (project == Project.ADVENTURE_MM) {
        return constructUrl(
            "https://jd.advntr.dev/text-minimessage/latest/",
            modifiedPath,
            methodPath,
        );
    }

    if (project == Project.JSPECIFY) {
        return constructUrl("https://jspecify.dev/docs/api/", modifiedPath, "");
    }

    if (project == Project.SLF4J) {
        return constructUrl(
            "https://www.slf4j.org/api/",
            modifiedPath,
            methodPath,
        );
    }

    throw "Invalid project!";
}

function constructUrl(base: string, path: string, method: string) {
    return base + path + ".html" + method;
}

function preprocessProps(props: Props) {
    if (props.id != null) {
        props.id = props.id.toLowerCase();
        props.path = idToFullPath(props.id);
    }

    if (props.params != null) {
        props.params = props.params.toLowerCase();
    }

    if (props.name == null) {
        const split: string[] | undefined = props.path?.split(".");
        props.name = split ? split[split.length - 1] : "<unknown>";
    }
}

function getProjectByPath(path: string): Project {
    let out: Project | undefined;

    projects
        .entries()
        .forEach((entry) =>
            path.startsWith(entry[0]) ? (out = entry[1]) : undefined,
        );

    if (out == null) {
        // Default to Paper if no other key was found
        return Project.PAPER;
    }

    return out;
}
---

<code dir="auto"><a href={fullPath}><slot>{name}</slot></a></code>
