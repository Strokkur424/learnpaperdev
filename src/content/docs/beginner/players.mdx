---
title: Working with Players
description: A beginner's guide to the player object.
slug: beginner/players
---

import JavaDocs from "../components/JavaDocs.astro";
import PreviewImage from "../components/PreviewImage.astro";
import PreviewVideo from "../components/PreviewVideo.astro";

import BlockBreakMessagePng from "./assets/players/block-break-message.png";
import PlayerListPng from "./assets/players/player-list.png";
import SneakFlyingMp4 from "./assets/players/sneak-flying.mp4";

One of the most used objects when developing for Paper is the <JavaDocs id="Player"/> object. It represents a player who is playing on your server. Through it you can send the player messages,
set their health, teleport them, and many other fun stuff!

## The `Player` is an `Audience`

The Adventure library's <JavaDocs id="Audience"/> object declares a lot of methods for sending messages or other UI elements to the player. You can see an overview with those on the
[adventure/audiences](/adventure/audiences) page!

## Sending Messages to Players

There is three main methods with which you can send messages to a player:

- <JavaDocs
    id="Audience"
    method="sendMessage(net.kyori.adventure.text.Component)"
    name="Player#sendMessage(Component)"
  />
- <JavaDocs
    id="CommandSender"
    method="sendRichMessage(java.lang.String,net.kyori.adventure.text.minimessage.tag.resolver.TagResolver...)"
    name="Player#sendRichMessage(String, TagResolver...)"
  />
- <JavaDocs
    id="CommandSender"
    method="sendPlainMessage(java.lang.String)"
    name="Player#sendPlainMessage(String)"
  />

The first one is declared in the <JavaDocs id="Audience"/> interface. You can send styled and colored messages with it! The second method is used for sending a **MiniMessage**-formatted string
to the player. Internally, this converts the string to a component and then uses <JavaDocs id="Audience" method="sendMessage(net.kyori.adventure.text.Component)" name="Player#sendMessage(Component)"/>.
You can optionally include [`TagResolvers` for custom tags](/adventure/tag-resolvers). The last method is for sending a non-parsed message to the client. This one will make no attempt to parse
the string's contents â€” what you put in is what gets send!

### Updating our block destroy listener

In our event handler in `BlockBreakListener.java`, we can replace the logger call with a `player#sendRichMessage`. Now you don't have to check the console!

<PreviewImage src={BlockBreakMessagePng} summary="Our new message" />

```java title="BlockBreakListener.java" startLineNumber=24 {10-15}
@EventHandler
void onBlockBreak(BlockBreakEvent event) {
    counter++;

    // Every second block break
    if (counter % 2 == 0) {
        event.setCancelled(true);
    }

    final Player player = event.getPlayer();
    player.sendRichMessage("Was block breaking of <gold><block></gold> cancelled: <color><b><cancelled>",
        Placeholder.component("block", Component.translatable(event.getBlock())),
        Placeholder.component("cancelled", Component.text(event.isCancelled())),
        Placeholder.styling("color", event.isCancelled() ? NamedTextColor.GREEN : NamedTextColor.RED)
    );
}
```

## Getting a Player's Position

Another set of often used methods are the positional methods. These include, but are not limited to:

- <JavaDocs id="Player" method="getRespawnLocation()" />
- <JavaDocs id="LivingEntity" method="getEyeLocation()" />
- <JavaDocs id="Entity" method="getLocation()" />
- <JavaDocs id="Entity" method="getX()" />, <JavaDocs id="Entity" method="getY()" />, and <JavaDocs id="Entity" method="getZ()" />
- <JavaDocs id="Entity" method="getPitch()" /> and <JavaDocs id="Entity" method="getYaw()" />
- <JavaDocs id="Entity" method="getFacing()" />
- <JavaDocs id="Entity" method="getVelocity()" />

All of these are accessible on a <JavaDocs id="Player" />, even if they originate from a different interface.
A <JavaDocs id="Location" /> object describes a `x`, `y`, and `z` position in a <JavaDocs id="World" />. It can also include `yaw` and `pitch` values. They are generally
**mutable**. That means that any operation, which modifies the mentioned values, will apply that change to itself as well. If you want to keep a location unmodified, you should
store a **copy** of that location by running <JavaDocs id="Location" method="clone()" />.

You can modify a <JavaDocs id="Location" /> with multiple methods and method overloads. Some of these include:

- <JavaDocs id="Location" method="add(double,double,double)" />
- <JavaDocs id="Location" method="multiply(double)" />
- <JavaDocs id="Location" method="subtract(double,double,double)" />
- <JavaDocs id="Location" method="set(double,double,double)" />
- <JavaDocs id="Location" method="setWorld" params="World world" name="Location#setWorld(World world)" />
- <JavaDocs id="Location" method="setX(double)" name="Location#setX(double x)"/>, <JavaDocs id="Location" method="setY(double)" name="Location#setY(double y)" />, <JavaDocs id="Location" method="setZ(double)" name="Location#setZ(double z)" />
- <JavaDocs id="Location" method="setPitch(float)" name="Location#setPitch(float pitch)" />, and <JavaDocs id="Location" method="setYaw(float)" name="Location#setYaw(float yaw)" />
- <JavaDocs id="Location" method="toHighestLocation()" />


### Applying a velocity when a player sneaks

When getting the location from <JavaDocs id="Player" method="getEyeLocation()"/>, you can get they player's current facing direction with <JavaDocs id="Location" method="getDirection()"/>.
You can then work with that direction. One example can be to check if the player is looking at something, which would be done with a ray trace. Since that is too complicated for us for now,
I instead chose the following, rather fun example:

Whenever the player sneaks (pressed the sneak button) they get a velocity applied to them! We apply the location with the <JavaDocs id="Player" method="ash"/> method, passing in
the vector of where our player is currently looking. This allows for a very fun flying mechanic! (Tip: to avoid getting kicked, set `allow-flight=true` in your `server.properties`).

<PreviewVideo src={SneakFlyingMp4} summary="Preview Video" />

```java title="PlayerSneakListener.java" collapse={1-8}
package com.learnpaperdev.beginner;

import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerToggleSneakEvent;
import org.bukkit.util.Vector;
import org.jspecify.annotations.NullMarked;

@NullMarked
public final class PlayerSneakListener implements Listener {

    @EventHandler
    void onPlayerSneak(PlayerToggleSneakEvent event) {
        // Only run if the player started sneaking to avoid double-calls
        if (!event.isSneaking()) {
            return;
        }

        final Player player = event.getPlayer();
        final Vector lookDirection = player.getEyeLocation().getDirection();

        player.setVelocity(lookDirection);
    }
}
```

Don't forget to register this listener in your main class!

```java title="BeginnerPlugin.java" startLineNumber=13 collapse={3-7} {11}
@Override
public void onEnable() {
    // We use a PluginManager in order to register events
    final PluginManager pluginManager = getServer().getPluginManager();

    // Create our listener instance
    final BlockBreakListener listener = new BlockBreakListener(getComponentLogger());

    // #registerEvents requires the listener we want to register, and our plugin instance
    pluginManager.registerEvents(listener, this);
    pluginManager.registerEvents(new PlayerSneakListener(), this);

    getComponentLogger().warn("Our plugin has been enabled!");
}
```

## Modifying the player list
The player list (tab list) can be modified using the follow methods:
- <JavaDocs id="Audience" method="sendPlayerListHeader(net.kyori.adventure.text.Component)" name="Player#sendPlayerListHeader(Component header)" />
- <JavaDocs id="Audience" method="sendPlayerListFooter(net.kyori.adventure.text.Component)" name="Player#sendPlayerListFooter(Component footer)" />

For modifying both at once, you can use:
- <JavaDocs id="Audience" method="sendPlayerListHeaderAndFooter(net.kyori.adventure.text.Component,net.kyori.adventure.text.Component)" name="Player#sendPlayerListHeaderAndFooter(Component header, Component footer)" />

There is also the possibility of setting a player's tab list display name: <JavaDocs id="Player" method="playerListName()" />.

### Setting the player's list on player join
We can write another listener which modifies the player's player list whenever they join the server. We can even style the player's name! In this case, we will
apply a **random gradient** whenever a player joins. Sounds fun, doesn't it? For this we will add a new event handler for the <JavaDocs id="PlayerJoinEvent" />.
The code that we have to write is pretty straight-forward. The one part that you may be unfamiliar with is the usage of the pre-process <JavaDocs id="Tag" />.
We use it in order to be able to put a tag into the parameters of the `<gradient>` tag, as otherwise, it would just use `<first_color>` and `<second_color>` as literal
parameters, which is not what we want!

<PreviewImage src={PlayerListPng} summary="Player List Preview"/>

```java title="PlayerJoinListener.java" collapse={1-14}
package com.learnpaperdev.beginner;

import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.format.TextColor;
import net.kyori.adventure.text.minimessage.tag.Tag;
import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
import net.kyori.adventure.text.minimessage.tag.resolver.TagResolver;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerJoinEvent;
import org.jspecify.annotations.NullMarked;

import java.util.Random;

import static net.kyori.adventure.text.minimessage.MiniMessage.miniMessage;

@NullMarked
public class PlayerJoinListener implements Listener {

    private final Random random = new Random();

    @EventHandler
    void onPlayerJoin(PlayerJoinEvent event) {
        final Player player = event.getPlayer();

        final Component header = miniMessage().deserialize("""
                <b><gradient:red:white>A Very Cool Title</b>
                """,
            Placeholder.component("player", player.name())
        );

        final Component footer = miniMessage().deserialize("""

            <gray>Enjoy your time here!</gray>"""
        );

        player.sendPlayerListHeaderAndFooter(header, footer);

        final TextColor firstColor = TextColor.color(random.nextInt(0xFFFFFF));
        final TextColor secondColor = TextColor.color(random.nextInt(0xFFFFFF));

        final Component playerName = miniMessage().deserialize("<b><gradient:<first_color>:<second_color>><playername>",
            TagResolver.resolver("first_color", Tag.preProcessParsed(firstColor.asHexString())),
            TagResolver.resolver("second_color", Tag.preProcessParsed(secondColor.asHexString())),
            Placeholder.component("playername", player.name())
        );

        player.playerListName(playerName);
    }
}
```

And again, don't forget to register this new listener.
```java title="BeginnerPlugin.java" {12} collapse={3-7} startLineNumber=13
@Override
public void onEnable() {
    // We use a PluginManager in order to register events
    final PluginManager pluginManager = getServer().getPluginManager();

    // Create our listener instance
    final BlockBreakListener listener = new BlockBreakListener(getComponentLogger());

    // #registerEvents requires the listener we want to register, and our plugin instance
    pluginManager.registerEvents(listener, this);
    pluginManager.registerEvents(new PlayerSneakListener(), this);
    pluginManager.registerEvents(new PlayerJoinListener(), this);

    getComponentLogger().warn("Our plugin has been enabled!");
}
```
