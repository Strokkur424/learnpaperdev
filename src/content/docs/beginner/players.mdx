---
title: Working with Players
description: A beginner's guide to the player object.
slug: beginner/players
---

import JavaDocs from "../components/JavaDocs.astro";
import PreviewImage from "../components/PreviewImage.astro";
import PreviewVideo from "../components/PreviewVideo.astro";

import BlockBreakMessagePng from "./assets/players/block-break-message.png";
import SneakFlyingMp4 from "./assets/players/sneak-flying.mp4";

One of the most used objects when developing for Paper is the <JavaDocs id="Player"/> object. It represents a player who is playing on your server. Through it you can send the player messages,
set their health, teleport them, and many other fun stuff!

## The `Player` is an `Audience`

The Adventure library's <JavaDocs id="Audience"/> object declares a lot of methods for sending messages or other UI elements to the player. You can see an overview with those on the
[adventure/audiences](/adventure/audiences) page!

## Sending Messages to Players

There is three main methods with which you can send messages to a player:

- <JavaDocs
    id="Audience"
    method="sendMessage(net.kyori.adventure.text.Component)"
    name="Player#sendMessage(Component)"
  />
- <JavaDocs
    id="CommandSender"
    method="sendRichMessage(java.lang.String,net.kyori.adventure.text.minimessage.tag.resolver.TagResolver...)"
    name="Player#sendRichMessage(String, TagResolver...)"
  />
- <JavaDocs
    id="CommandSender"
    method="sendPlainMessage(java.lang.String)"
    name="Player#sendPlainMessage(String)"
  />

The first one is declared in the <JavaDocs id="Audience"/> interface. You can send styled and colored messages with it! The second method is used for sending a **MiniMessage**-formatted string
to the player. Internally, this converts the string to a component and then uses <JavaDocs id="Audience" method="sendMessage(net.kyori.adventure.text.Component)" name="Player#sendMessage(Component)"/>.
You can optionally include [`TagResolvers` for custom tags](/adventure/tag-resolvers). The last method is for sending a non-parsed message to the client. This one will make no attempt to parse
the string's contents â€” what you put in is what gets send!

### Example: Updating our block destroy listener

In our event handler in `BlockBreakListener.java`, we can replace the logger call with a `player#sendRichMessage`. Now you don't have to check the console!

<PreviewImage src={BlockBreakMessagePng} summary="Our new message" />

```java title="BlockBreakListener.java" startLineNumber=24 {10-15}
@EventHandler
void onBlockBreak(BlockBreakEvent event) {
    counter++;

    // Every second block break
    if (counter % 2 == 0) {
        event.setCancelled(true);
    }

    final Player player = event.getPlayer();
    player.sendRichMessage("Was block breaking of <gold><block></gold> cancelled: <color><b><cancelled>",
        Placeholder.component("block", Component.translatable(event.getBlock())),
        Placeholder.component("cancelled", Component.text(event.isCancelled())),
        Placeholder.styling("color", event.isCancelled() ? NamedTextColor.GREEN : NamedTextColor.RED)
    );
}
```

## Getting a Player's Position

Another set of often used methods are the positional methods. These include, but are not limited to:

- <JavaDocs id="Player" method="getRespawnLocation()" />
- <JavaDocs id="LivingEntity" method="getEyeLocation()" />
- <JavaDocs id="Entity" method="getLocation()" />
- <JavaDocs id="Entity" method="getX()" />, <JavaDocs id="Entity" method="getY()" />, and <JavaDocs id="Entity" method="getZ()" />
- <JavaDocs id="Entity" method="getPitch()" /> and <JavaDocs id="Entity" method="getYaw()" />
- <JavaDocs id="Entity" method="getFacing()" />
- <JavaDocs id="Entity" method="getVelocity()" />

All of these are accessible on a <JavaDocs id="Player" />, even if they originate from a different interface.
A <JavaDocs id="Location" /> object describes a `x`, `y`, and `z` position in a <JavaDocs id="World" />. It can also include `yaw` and `pitch` values. They are generally
**mutable**. That means that any operation, which modifies the mentioned values, will apply that change to itself as well. If you want to keep a location unmodified, you should
store a **copy** of that location by running <JavaDocs id="Location" method="clone()" />.

You can modify a <JavaDocs id="Location" /> with multiple methods and method overloads. Some of these include:

- <JavaDocs id="Location" method="add(double,double,double)" />
- <JavaDocs id="Location" method="multiply(double)" />
- <JavaDocs id="Location" method="subtract(double,double,double)" />
- <JavaDocs id="Location" method="set(double,double,double)" />
- <JavaDocs id="Location" method="setWorld" params="World world" name="Location#setWorld(World world)" />
- <JavaDocs id="Location" method="setX(double)" name="Location#setX(double x)"/>, <JavaDocs id="Location" method="setY(double)" name="Location#setY(double y)" />, <JavaDocs id="Location" method="setZ(double)" name="Location#setZ(double z)" />
- <JavaDocs id="Location" method="setPitch(float)" name="Location#setPitch(float pitch)" />, and <JavaDocs id="Location" method="setYaw(float)" name="Location#setYaw(float yaw)" />
- <JavaDocs id="Location" method="toHighestLocation()" />



### Example: Applying a velocity when a player sneaks

When getting the location from <JavaDocs id="Player" method="getEyeLocation()"/>, you can get they player's current facing direction with <JavaDocs id="Location" method="getDirection()"/>.
You can then work with that direction. One example can be to check if the player is looking at something, which would be done with a ray trace. Since that is too complicated for us for now,
I instead chose the following, rather fun example:

Whenever the player sneaks (pressed the sneak button) they get a velocity applied to them! We apply the location with the <JavaDocs id="Player" method="ash"/> method, passing in
the vector of where our player is currently looking. This allows for a very fun flying mechanic! (Tip: to avoid getting kicked, set `allow-flight=true` in your `server.properties`).

<PreviewVideo src={SneakFlyingMp4} summary="Preview Video" />

```java title="PlayerSneakListener.java" collapse={1-8}
package com.learnpaperdev.beginner;

import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerToggleSneakEvent;
import org.bukkit.util.Vector;
import org.jspecify.annotations.NullMarked;

@NullMarked
public final class PlayerSneakListener implements Listener {

    @EventHandler
    void onPlayerSneak(PlayerToggleSneakEvent event) {
        // Only run if the player started sneaking to avoid double-calls
        if (!event.isSneaking()) {
            return;
        }

        final Player player = event.getPlayer();
        final Vector lookDirection = player.getEyeLocation().getDirection();

        player.setVelocity(lookDirection);
    }
}
```

Don't forget to register this listener in your main class!

```java title="BeginnerPlugin.java" startLineNumber=13 collapse={3-7} {11}
@Override
public void onEnable() {
    // We use a PluginManager in order to register events
    final PluginManager pluginManager = getServer().getPluginManager();

    // Create our listener instance
    final BlockBreakListener listener = new BlockBreakListener(getComponentLogger());

    // #registerEvents requires the listener we want to register, and our plugin instance
    pluginManager.registerEvents(listener, this);
    pluginManager.registerEvents(new PlayerSneakListener(), this);

    getComponentLogger().warn("Our plugin has been enabled!");
}
```
